<template>
    <div class="obg-carousel-container">
        <div class="obg-carousel-slider">
            <slot></slot>
        </div>
    </div>
</template>

<script>
  /**
   * @class cover-flow
   * @classdesc components/cover-flow
   * @param {number} [display=5] display count
   * @param {number} [perspective=35] degree of slide
   * @param {boolean} [loop=true]
   * @param {number} [animationSpeed=500] ms
   * @param {string} [dir=rtl] rtl | ltr
   * @param {number} [startIndex=0]
   * @param {number} [width=300]
   * @param {number} [height=210]
   * @param {function} [onSlideChange]
   * @param {function] [onLastSlide]
   * @param {slot} [slot] Cover-slide
   *
   * @example
   * import {CoverFlow, CoverSlide} from 'obigo-js-ui/components/cover-flow'
   * <obg-cover-flow
   *   @input="onChange"
   * >
   *   <obg-cover-slide v-for="n in 11" :index="n-1">
   *     Slide {{n}} Content
   *   </obg-cover-slide>
   * </obg-cover-flow>
   */
  import {parentMixin} from '../../mixins/cover-flow'
  export default {
    name: 'obg-cover-flow',
    mixins: [parentMixin],
    props: {
      perspective: {
        type: Number,
        default: 35
      },
      display: {
        type: Number,
        default: 5
      },
      width: {
        type: Number,
        default: 300
      },
      height: {
        type: Number,
        default: 210
      },
      inverseScaling: {
        type: Number,
        default: 300
      }
    },
    data () {
      return {
        dragStartX: 0
      }
    },
    methods: {
      /**
       * Trigger actions when mouse is pressed
       * @param  {Object} e The event object
       */
      handleMousedown (e) {
        e.preventDefault()

        this.mousedown = true
        this.dragStartX = e.clientX
      },
      /**
       * Trigger actions when mouse is pressed and then moved (mouse drag)
       * @param  {Object} e The event object
       */
      handleMousemove (e) {
        if (!this.mousedown) {
          return
        }

        const eventPosX = e.clientX
        const deltaX = (this.dragStartX - eventPosX)

        this.dragOffset = deltaX

        if (this.dragOffset > this.minSwipeDistance) {
          this.handleMouseup()
          this.goNext()
        } else if (this.dragOffset < -this.minSwipeDistance) {
          this.handleMouseup()
          this.goPrev()
        }
      },
      /**
       * Re-compute the number of slides and current slide
       */
      computeData () {
        this.total = this.getSlideCount()
        this.currentIndex = this.startIndex > this.total - 1 ? this.total - 1 : this.startIndex
        this.viewport = this.$el.clientWidth
      },
      setSize () {
        this.$el.style.cssText += 'height:' + this.slideHeight
        this.$el.childNodes[0].style.cssText += 'width:' + this.slideWidth + 'px;' + ' height:' + this.slideHeight + 'px'
      }
    }
  }
</script>

<style lang="scss" scoped>
  .obg-carousel-container {
    width: 100%;
    position: relative;
    z-index: 0;
    overflow: hidden;
    margin: 20px auto;
    box-sizing: border-box;
    & > .obg-carousel-slider {
      position: relative;
      margin: 0 auto;
      transform-style: preserve-3d;
      -webkit-perspective: 1000px;
      perspective: 1000px;
    }
  }



</style>
